// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package slicy

// SliceOfByte is a struct containing needed data for storing slice items data
type SliceOfByte struct {
	items []byte
}

// NewFromByteSlice creates an instance of SliceOfByte and returns a reference to it
func NewFromByteSlice(items []byte) *SliceOfByte {
	slicy := &SliceOfByte{items}
	return slicy
}

// Filter gets a filter function which gets a single byte and only preserve items with true return value from that function
func (s *SliceOfByte) Filter(filterFunc func(byte) bool) *SliceOfByte {
	var newItems []byte
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single byte items and sets that item with returned value from function
func (s *SliceOfByte) Map(mapFunc func(byte) byte) *SliceOfByte {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first byte item from the slice
func (s *SliceOfByte) Shift() *SliceOfByte {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given byte to the start of the slice
func (s *SliceOfByte) Unshift(item byte) *SliceOfByte {
	s.items = append([]byte{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfByte) Append(item byte) *SliceOfByte {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfByte) Concat(items []byte) *SliceOfByte {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the byte item at the end of the slice
func (s *SliceOfByte) Push(item byte) *SliceOfByte {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the byte item from the end of the slice
func (s *SliceOfByte) Pop() *SliceOfByte {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single byte items and returns true if the function returne true for all of the them
func (s *SliceOfByte) Every(checkerFunc func(byte) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single byte items and returns true if the function returne true for one or more of the them
func (s *SliceOfByte) Some(checkerFunc func(byte) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfByte) Includes(item byte) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfByte) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of byte
func (s *SliceOfByte) GetSlice() *[]byte {
	return &s.items
}

// SliceOfInt is a struct containing needed data for storing slice items data
type SliceOfInt struct {
	items []int
}

// NewFromIntSlice creates an instance of SliceOfInt and returns a reference to it
func NewFromIntSlice(items []int) *SliceOfInt {
	slicy := &SliceOfInt{items}
	return slicy
}

// Filter gets a filter function which gets a single int and only preserve items with true return value from that function
func (s *SliceOfInt) Filter(filterFunc func(int) bool) *SliceOfInt {
	var newItems []int
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single int items and sets that item with returned value from function
func (s *SliceOfInt) Map(mapFunc func(int) int) *SliceOfInt {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first int item from the slice
func (s *SliceOfInt) Shift() *SliceOfInt {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given int to the start of the slice
func (s *SliceOfInt) Unshift(item int) *SliceOfInt {
	s.items = append([]int{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfInt) Append(item int) *SliceOfInt {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfInt) Concat(items []int) *SliceOfInt {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the int item at the end of the slice
func (s *SliceOfInt) Push(item int) *SliceOfInt {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the int item from the end of the slice
func (s *SliceOfInt) Pop() *SliceOfInt {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single int items and returns true if the function returne true for all of the them
func (s *SliceOfInt) Every(checkerFunc func(int) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single int items and returns true if the function returne true for one or more of the them
func (s *SliceOfInt) Some(checkerFunc func(int) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfInt) Includes(item int) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfInt) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of int
func (s *SliceOfInt) GetSlice() *[]int {
	return &s.items
}

// SliceOfInt8 is a struct containing needed data for storing slice items data
type SliceOfInt8 struct {
	items []int8
}

// NewFromInt8Slice creates an instance of SliceOfInt8 and returns a reference to it
func NewFromInt8Slice(items []int8) *SliceOfInt8 {
	slicy := &SliceOfInt8{items}
	return slicy
}

// Filter gets a filter function which gets a single int8 and only preserve items with true return value from that function
func (s *SliceOfInt8) Filter(filterFunc func(int8) bool) *SliceOfInt8 {
	var newItems []int8
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single int8 items and sets that item with returned value from function
func (s *SliceOfInt8) Map(mapFunc func(int8) int8) *SliceOfInt8 {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first int8 item from the slice
func (s *SliceOfInt8) Shift() *SliceOfInt8 {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given int8 to the start of the slice
func (s *SliceOfInt8) Unshift(item int8) *SliceOfInt8 {
	s.items = append([]int8{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfInt8) Append(item int8) *SliceOfInt8 {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfInt8) Concat(items []int8) *SliceOfInt8 {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the int8 item at the end of the slice
func (s *SliceOfInt8) Push(item int8) *SliceOfInt8 {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the int8 item from the end of the slice
func (s *SliceOfInt8) Pop() *SliceOfInt8 {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single int8 items and returns true if the function returne true for all of the them
func (s *SliceOfInt8) Every(checkerFunc func(int8) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single int8 items and returns true if the function returne true for one or more of the them
func (s *SliceOfInt8) Some(checkerFunc func(int8) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfInt8) Includes(item int8) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfInt8) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of int8
func (s *SliceOfInt8) GetSlice() *[]int8 {
	return &s.items
}

// SliceOfInt16 is a struct containing needed data for storing slice items data
type SliceOfInt16 struct {
	items []int16
}

// NewFromInt16Slice creates an instance of SliceOfInt16 and returns a reference to it
func NewFromInt16Slice(items []int16) *SliceOfInt16 {
	slicy := &SliceOfInt16{items}
	return slicy
}

// Filter gets a filter function which gets a single int16 and only preserve items with true return value from that function
func (s *SliceOfInt16) Filter(filterFunc func(int16) bool) *SliceOfInt16 {
	var newItems []int16
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single int16 items and sets that item with returned value from function
func (s *SliceOfInt16) Map(mapFunc func(int16) int16) *SliceOfInt16 {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first int16 item from the slice
func (s *SliceOfInt16) Shift() *SliceOfInt16 {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given int16 to the start of the slice
func (s *SliceOfInt16) Unshift(item int16) *SliceOfInt16 {
	s.items = append([]int16{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfInt16) Append(item int16) *SliceOfInt16 {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfInt16) Concat(items []int16) *SliceOfInt16 {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the int16 item at the end of the slice
func (s *SliceOfInt16) Push(item int16) *SliceOfInt16 {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the int16 item from the end of the slice
func (s *SliceOfInt16) Pop() *SliceOfInt16 {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single int16 items and returns true if the function returne true for all of the them
func (s *SliceOfInt16) Every(checkerFunc func(int16) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single int16 items and returns true if the function returne true for one or more of the them
func (s *SliceOfInt16) Some(checkerFunc func(int16) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfInt16) Includes(item int16) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfInt16) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of int16
func (s *SliceOfInt16) GetSlice() *[]int16 {
	return &s.items
}

// SliceOfInt32 is a struct containing needed data for storing slice items data
type SliceOfInt32 struct {
	items []int32
}

// NewFromInt32Slice creates an instance of SliceOfInt32 and returns a reference to it
func NewFromInt32Slice(items []int32) *SliceOfInt32 {
	slicy := &SliceOfInt32{items}
	return slicy
}

// Filter gets a filter function which gets a single int32 and only preserve items with true return value from that function
func (s *SliceOfInt32) Filter(filterFunc func(int32) bool) *SliceOfInt32 {
	var newItems []int32
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single int32 items and sets that item with returned value from function
func (s *SliceOfInt32) Map(mapFunc func(int32) int32) *SliceOfInt32 {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first int32 item from the slice
func (s *SliceOfInt32) Shift() *SliceOfInt32 {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given int32 to the start of the slice
func (s *SliceOfInt32) Unshift(item int32) *SliceOfInt32 {
	s.items = append([]int32{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfInt32) Append(item int32) *SliceOfInt32 {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfInt32) Concat(items []int32) *SliceOfInt32 {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the int32 item at the end of the slice
func (s *SliceOfInt32) Push(item int32) *SliceOfInt32 {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the int32 item from the end of the slice
func (s *SliceOfInt32) Pop() *SliceOfInt32 {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single int32 items and returns true if the function returne true for all of the them
func (s *SliceOfInt32) Every(checkerFunc func(int32) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single int32 items and returns true if the function returne true for one or more of the them
func (s *SliceOfInt32) Some(checkerFunc func(int32) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfInt32) Includes(item int32) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfInt32) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of int32
func (s *SliceOfInt32) GetSlice() *[]int32 {
	return &s.items
}

// SliceOfInt64 is a struct containing needed data for storing slice items data
type SliceOfInt64 struct {
	items []int64
}

// NewFromInt64Slice creates an instance of SliceOfInt64 and returns a reference to it
func NewFromInt64Slice(items []int64) *SliceOfInt64 {
	slicy := &SliceOfInt64{items}
	return slicy
}

// Filter gets a filter function which gets a single int64 and only preserve items with true return value from that function
func (s *SliceOfInt64) Filter(filterFunc func(int64) bool) *SliceOfInt64 {
	var newItems []int64
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single int64 items and sets that item with returned value from function
func (s *SliceOfInt64) Map(mapFunc func(int64) int64) *SliceOfInt64 {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first int64 item from the slice
func (s *SliceOfInt64) Shift() *SliceOfInt64 {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given int64 to the start of the slice
func (s *SliceOfInt64) Unshift(item int64) *SliceOfInt64 {
	s.items = append([]int64{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfInt64) Append(item int64) *SliceOfInt64 {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfInt64) Concat(items []int64) *SliceOfInt64 {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the int64 item at the end of the slice
func (s *SliceOfInt64) Push(item int64) *SliceOfInt64 {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the int64 item from the end of the slice
func (s *SliceOfInt64) Pop() *SliceOfInt64 {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single int64 items and returns true if the function returne true for all of the them
func (s *SliceOfInt64) Every(checkerFunc func(int64) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single int64 items and returns true if the function returne true for one or more of the them
func (s *SliceOfInt64) Some(checkerFunc func(int64) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfInt64) Includes(item int64) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfInt64) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of int64
func (s *SliceOfInt64) GetSlice() *[]int64 {
	return &s.items
}

// SliceOfFloat32 is a struct containing needed data for storing slice items data
type SliceOfFloat32 struct {
	items []float32
}

// NewFromFloat32Slice creates an instance of SliceOfFloat32 and returns a reference to it
func NewFromFloat32Slice(items []float32) *SliceOfFloat32 {
	slicy := &SliceOfFloat32{items}
	return slicy
}

// Filter gets a filter function which gets a single float32 and only preserve items with true return value from that function
func (s *SliceOfFloat32) Filter(filterFunc func(float32) bool) *SliceOfFloat32 {
	var newItems []float32
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single float32 items and sets that item with returned value from function
func (s *SliceOfFloat32) Map(mapFunc func(float32) float32) *SliceOfFloat32 {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first float32 item from the slice
func (s *SliceOfFloat32) Shift() *SliceOfFloat32 {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given float32 to the start of the slice
func (s *SliceOfFloat32) Unshift(item float32) *SliceOfFloat32 {
	s.items = append([]float32{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfFloat32) Append(item float32) *SliceOfFloat32 {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfFloat32) Concat(items []float32) *SliceOfFloat32 {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the float32 item at the end of the slice
func (s *SliceOfFloat32) Push(item float32) *SliceOfFloat32 {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the float32 item from the end of the slice
func (s *SliceOfFloat32) Pop() *SliceOfFloat32 {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single float32 items and returns true if the function returne true for all of the them
func (s *SliceOfFloat32) Every(checkerFunc func(float32) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single float32 items and returns true if the function returne true for one or more of the them
func (s *SliceOfFloat32) Some(checkerFunc func(float32) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfFloat32) Includes(item float32) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfFloat32) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of float32
func (s *SliceOfFloat32) GetSlice() *[]float32 {
	return &s.items
}

// SliceOfFloat64 is a struct containing needed data for storing slice items data
type SliceOfFloat64 struct {
	items []float64
}

// NewFromFloat64Slice creates an instance of SliceOfFloat64 and returns a reference to it
func NewFromFloat64Slice(items []float64) *SliceOfFloat64 {
	slicy := &SliceOfFloat64{items}
	return slicy
}

// Filter gets a filter function which gets a single float64 and only preserve items with true return value from that function
func (s *SliceOfFloat64) Filter(filterFunc func(float64) bool) *SliceOfFloat64 {
	var newItems []float64
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single float64 items and sets that item with returned value from function
func (s *SliceOfFloat64) Map(mapFunc func(float64) float64) *SliceOfFloat64 {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first float64 item from the slice
func (s *SliceOfFloat64) Shift() *SliceOfFloat64 {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given float64 to the start of the slice
func (s *SliceOfFloat64) Unshift(item float64) *SliceOfFloat64 {
	s.items = append([]float64{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfFloat64) Append(item float64) *SliceOfFloat64 {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfFloat64) Concat(items []float64) *SliceOfFloat64 {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the float64 item at the end of the slice
func (s *SliceOfFloat64) Push(item float64) *SliceOfFloat64 {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the float64 item from the end of the slice
func (s *SliceOfFloat64) Pop() *SliceOfFloat64 {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single float64 items and returns true if the function returne true for all of the them
func (s *SliceOfFloat64) Every(checkerFunc func(float64) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single float64 items and returns true if the function returne true for one or more of the them
func (s *SliceOfFloat64) Some(checkerFunc func(float64) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfFloat64) Includes(item float64) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfFloat64) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of float64
func (s *SliceOfFloat64) GetSlice() *[]float64 {
	return &s.items
}

// SliceOfUint is a struct containing needed data for storing slice items data
type SliceOfUint struct {
	items []uint
}

// NewFromUintSlice creates an instance of SliceOfUint and returns a reference to it
func NewFromUintSlice(items []uint) *SliceOfUint {
	slicy := &SliceOfUint{items}
	return slicy
}

// Filter gets a filter function which gets a single uint and only preserve items with true return value from that function
func (s *SliceOfUint) Filter(filterFunc func(uint) bool) *SliceOfUint {
	var newItems []uint
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single uint items and sets that item with returned value from function
func (s *SliceOfUint) Map(mapFunc func(uint) uint) *SliceOfUint {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first uint item from the slice
func (s *SliceOfUint) Shift() *SliceOfUint {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given uint to the start of the slice
func (s *SliceOfUint) Unshift(item uint) *SliceOfUint {
	s.items = append([]uint{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfUint) Append(item uint) *SliceOfUint {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfUint) Concat(items []uint) *SliceOfUint {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the uint item at the end of the slice
func (s *SliceOfUint) Push(item uint) *SliceOfUint {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the uint item from the end of the slice
func (s *SliceOfUint) Pop() *SliceOfUint {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single uint items and returns true if the function returne true for all of the them
func (s *SliceOfUint) Every(checkerFunc func(uint) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single uint items and returns true if the function returne true for one or more of the them
func (s *SliceOfUint) Some(checkerFunc func(uint) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfUint) Includes(item uint) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfUint) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of uint
func (s *SliceOfUint) GetSlice() *[]uint {
	return &s.items
}

// SliceOfUint8 is a struct containing needed data for storing slice items data
type SliceOfUint8 struct {
	items []uint8
}

// NewFromUint8Slice creates an instance of SliceOfUint8 and returns a reference to it
func NewFromUint8Slice(items []uint8) *SliceOfUint8 {
	slicy := &SliceOfUint8{items}
	return slicy
}

// Filter gets a filter function which gets a single uint8 and only preserve items with true return value from that function
func (s *SliceOfUint8) Filter(filterFunc func(uint8) bool) *SliceOfUint8 {
	var newItems []uint8
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single uint8 items and sets that item with returned value from function
func (s *SliceOfUint8) Map(mapFunc func(uint8) uint8) *SliceOfUint8 {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first uint8 item from the slice
func (s *SliceOfUint8) Shift() *SliceOfUint8 {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given uint8 to the start of the slice
func (s *SliceOfUint8) Unshift(item uint8) *SliceOfUint8 {
	s.items = append([]uint8{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfUint8) Append(item uint8) *SliceOfUint8 {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfUint8) Concat(items []uint8) *SliceOfUint8 {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the uint8 item at the end of the slice
func (s *SliceOfUint8) Push(item uint8) *SliceOfUint8 {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the uint8 item from the end of the slice
func (s *SliceOfUint8) Pop() *SliceOfUint8 {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single uint8 items and returns true if the function returne true for all of the them
func (s *SliceOfUint8) Every(checkerFunc func(uint8) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single uint8 items and returns true if the function returne true for one or more of the them
func (s *SliceOfUint8) Some(checkerFunc func(uint8) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfUint8) Includes(item uint8) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfUint8) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of uint8
func (s *SliceOfUint8) GetSlice() *[]uint8 {
	return &s.items
}

// SliceOfUint16 is a struct containing needed data for storing slice items data
type SliceOfUint16 struct {
	items []uint16
}

// NewFromUint16Slice creates an instance of SliceOfUint16 and returns a reference to it
func NewFromUint16Slice(items []uint16) *SliceOfUint16 {
	slicy := &SliceOfUint16{items}
	return slicy
}

// Filter gets a filter function which gets a single uint16 and only preserve items with true return value from that function
func (s *SliceOfUint16) Filter(filterFunc func(uint16) bool) *SliceOfUint16 {
	var newItems []uint16
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single uint16 items and sets that item with returned value from function
func (s *SliceOfUint16) Map(mapFunc func(uint16) uint16) *SliceOfUint16 {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first uint16 item from the slice
func (s *SliceOfUint16) Shift() *SliceOfUint16 {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given uint16 to the start of the slice
func (s *SliceOfUint16) Unshift(item uint16) *SliceOfUint16 {
	s.items = append([]uint16{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfUint16) Append(item uint16) *SliceOfUint16 {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfUint16) Concat(items []uint16) *SliceOfUint16 {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the uint16 item at the end of the slice
func (s *SliceOfUint16) Push(item uint16) *SliceOfUint16 {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the uint16 item from the end of the slice
func (s *SliceOfUint16) Pop() *SliceOfUint16 {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single uint16 items and returns true if the function returne true for all of the them
func (s *SliceOfUint16) Every(checkerFunc func(uint16) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single uint16 items and returns true if the function returne true for one or more of the them
func (s *SliceOfUint16) Some(checkerFunc func(uint16) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfUint16) Includes(item uint16) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfUint16) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of uint16
func (s *SliceOfUint16) GetSlice() *[]uint16 {
	return &s.items
}

// SliceOfUint32 is a struct containing needed data for storing slice items data
type SliceOfUint32 struct {
	items []uint32
}

// NewFromUint32Slice creates an instance of SliceOfUint32 and returns a reference to it
func NewFromUint32Slice(items []uint32) *SliceOfUint32 {
	slicy := &SliceOfUint32{items}
	return slicy
}

// Filter gets a filter function which gets a single uint32 and only preserve items with true return value from that function
func (s *SliceOfUint32) Filter(filterFunc func(uint32) bool) *SliceOfUint32 {
	var newItems []uint32
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single uint32 items and sets that item with returned value from function
func (s *SliceOfUint32) Map(mapFunc func(uint32) uint32) *SliceOfUint32 {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first uint32 item from the slice
func (s *SliceOfUint32) Shift() *SliceOfUint32 {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given uint32 to the start of the slice
func (s *SliceOfUint32) Unshift(item uint32) *SliceOfUint32 {
	s.items = append([]uint32{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfUint32) Append(item uint32) *SliceOfUint32 {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfUint32) Concat(items []uint32) *SliceOfUint32 {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the uint32 item at the end of the slice
func (s *SliceOfUint32) Push(item uint32) *SliceOfUint32 {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the uint32 item from the end of the slice
func (s *SliceOfUint32) Pop() *SliceOfUint32 {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single uint32 items and returns true if the function returne true for all of the them
func (s *SliceOfUint32) Every(checkerFunc func(uint32) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single uint32 items and returns true if the function returne true for one or more of the them
func (s *SliceOfUint32) Some(checkerFunc func(uint32) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfUint32) Includes(item uint32) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfUint32) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of uint32
func (s *SliceOfUint32) GetSlice() *[]uint32 {
	return &s.items
}

// SliceOfUint64 is a struct containing needed data for storing slice items data
type SliceOfUint64 struct {
	items []uint64
}

// NewFromUint64Slice creates an instance of SliceOfUint64 and returns a reference to it
func NewFromUint64Slice(items []uint64) *SliceOfUint64 {
	slicy := &SliceOfUint64{items}
	return slicy
}

// Filter gets a filter function which gets a single uint64 and only preserve items with true return value from that function
func (s *SliceOfUint64) Filter(filterFunc func(uint64) bool) *SliceOfUint64 {
	var newItems []uint64
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single uint64 items and sets that item with returned value from function
func (s *SliceOfUint64) Map(mapFunc func(uint64) uint64) *SliceOfUint64 {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first uint64 item from the slice
func (s *SliceOfUint64) Shift() *SliceOfUint64 {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given uint64 to the start of the slice
func (s *SliceOfUint64) Unshift(item uint64) *SliceOfUint64 {
	s.items = append([]uint64{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfUint64) Append(item uint64) *SliceOfUint64 {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfUint64) Concat(items []uint64) *SliceOfUint64 {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the uint64 item at the end of the slice
func (s *SliceOfUint64) Push(item uint64) *SliceOfUint64 {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the uint64 item from the end of the slice
func (s *SliceOfUint64) Pop() *SliceOfUint64 {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single uint64 items and returns true if the function returne true for all of the them
func (s *SliceOfUint64) Every(checkerFunc func(uint64) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single uint64 items and returns true if the function returne true for one or more of the them
func (s *SliceOfUint64) Some(checkerFunc func(uint64) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfUint64) Includes(item uint64) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfUint64) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of uint64
func (s *SliceOfUint64) GetSlice() *[]uint64 {
	return &s.items
}

// SliceOfString is a struct containing needed data for storing slice items data
type SliceOfString struct {
	items []string
}

// NewFromStringSlice creates an instance of SliceOfString and returns a reference to it
func NewFromStringSlice(items []string) *SliceOfString {
	slicy := &SliceOfString{items}
	return slicy
}

// Filter gets a filter function which gets a single string and only preserve items with true return value from that function
func (s *SliceOfString) Filter(filterFunc func(string) bool) *SliceOfString {
	var newItems []string
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single string items and sets that item with returned value from function
func (s *SliceOfString) Map(mapFunc func(string) string) *SliceOfString {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first string item from the slice
func (s *SliceOfString) Shift() *SliceOfString {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given string to the start of the slice
func (s *SliceOfString) Unshift(item string) *SliceOfString {
	s.items = append([]string{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfString) Append(item string) *SliceOfString {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfString) Concat(items []string) *SliceOfString {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the string item at the end of the slice
func (s *SliceOfString) Push(item string) *SliceOfString {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the string item from the end of the slice
func (s *SliceOfString) Pop() *SliceOfString {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single string items and returns true if the function returne true for all of the them
func (s *SliceOfString) Every(checkerFunc func(string) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single string items and returns true if the function returne true for one or more of the them
func (s *SliceOfString) Some(checkerFunc func(string) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfString) Includes(item string) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfString) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of string
func (s *SliceOfString) GetSlice() *[]string {
	return &s.items
}

// SliceOfInterface is a struct containing needed data for storing slice items data
type SliceOfInterface struct {
	items []interface{}
}

// NewFromInterfaceSlice creates an instance of SliceOfInterface and returns a reference to it
func NewFromInterfaceSlice(items []interface{}) *SliceOfInterface {
	slicy := &SliceOfInterface{items}
	return slicy
}

// Filter gets a filter function which gets a single interface{} and only preserve items with true return value from that function
func (s *SliceOfInterface) Filter(filterFunc func(interface{}) bool) *SliceOfInterface {
	var newItems []interface{}
	for _, value := range s.items {
		if filterFunc(value) {
			newItems = append(newItems, value)
		}
	}
	return s
}

// Map gets a mapper function and runs that on every single interface{} items and sets that item with returned value from function
func (s *SliceOfInterface) Map(mapFunc func(interface{}) interface{}) *SliceOfInterface {
	for index, value := range s.items {
		s.items[index] = mapFunc(value)
	}
	return s
}

// Shift removes first interface{} item from the slice
func (s *SliceOfInterface) Shift() *SliceOfInterface {
	s.items = s.items[1:]
	return s
}

// Unshift adds the given interface{} to the start of the slice
func (s *SliceOfInterface) Unshift(item interface{}) *SliceOfInterface {
	s.items = append([]interface{}{item}, s.items...)
	return s
}

// Append adds the given item to the end of the slice
func (s *SliceOfInterface) Append(item interface{}) *SliceOfInterface {
	s.items = append(s.items, item)
	return s
}

// Concat concats another slice and adds the items in that to the end of current slice
func (s *SliceOfInterface) Concat(items []interface{}) *SliceOfInterface {
	s.items = append(s.items, items...)
	return s
}

// Push pushes the interface{} item at the end of the slice
func (s *SliceOfInterface) Push(item interface{}) *SliceOfInterface {
	s.items = append(s.items, item)
	return s
}

// Pop deletes the interface{} item from the end of the slice
func (s *SliceOfInterface) Pop() *SliceOfInterface {
	s.items = s.items[:len(s.items)-1]
	return s
}

// Every gets a checker function and runs that on every single interface{} items and returns true if the function returne true for all of the them
func (s *SliceOfInterface) Every(checkerFunc func(interface{}) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) == false {
			return false
		}
	}
	return true
}

// Some gets a checker function and runs that on every single interface{} items and returns true if the function returne true for one or more of the them
func (s *SliceOfInterface) Some(checkerFunc func(interface{}) bool) bool {
	for _, value := range s.items {
		if checkerFunc(value) {
			return true
		}
	}
	return false
}

// Includes returns true if the slice contains given item
func (s *SliceOfInterface) Includes(item interface{}) bool {
	for _, value := range s.items {
		if value == item {
			return true
		}
	}
	return false
}

// Len returns the length of items in current slice
func (s *SliceOfInterface) Len() int {
	return len(s.items)
}

// GetSlice returns a pointer to the final slice of interface{}
func (s *SliceOfInterface) GetSlice() *[]interface{} {
	return &s.items
}
